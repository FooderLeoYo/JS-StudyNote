# 正则

## 目录

[正则表达式在JS中的使用](#jump1)

[普通字符](#jump2)

[非打印字符](#jump3)

[特殊字符](#jump4)

[限定符](#jump5)

[定位符](#jump6)

[?=、?<=、?!、?<!= 的使用区别](#jump7)

[反向引用](#jump8)

[修饰符（标记）](#jump9)

[运算符优先级](#jump10)

[正则表达式中的替换](#jump11)

---	

<span id="jump1"></span>

## 正则表达式在JS中的使用

### 创建正则表达式的方法
		
1. 利用字面量创建(最常用)

```javascript
let 变量名 = /表达式/;
```

2. 利用 RegExp对象来创建

```javascript
let 变量名 = new RegExp(/表达式/);
```

**注意：**正则表达式里面不需要加引号，不管是数字型还是字符串型

### test方法

用来检测字符串是否符合正则表达式要求的规范，返回布尔值

```javascript
正则变量.test(输入的内容)
```

---

<span id="jump2"></span>

## 普通字符

包括所有大写和小写字母、所有数字、所有标点符号

### 一些普通字符的预定义类

预定义类指的是某些常见模式的简写方式

| 字符 | 描述 |
| --- | --- |
| \d | 匹配0-9之间的任意的数字 |
| \D | \d取反 |
| \w | 匹配任意的字母、数字、和下划线 |
| \W | \w取反 |

---

<span id="jump3"></span>

## 非打印字符

| 字符 | 描述 |
| --- | --- |
| \cx | 匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符 |
| \f | 匹配一个换页符 |
| \n | 匹配一个换行符 |
| \r | 匹配一个回车符 |
| \s | 匹配任何空白字符，包括空格、制表符、换页符等等 |
| \S | 匹配任何非空白字符 |
| \t | 匹配一个制表符 |
| \v | 匹配一个垂直制表符 |

---

<span id="jump4"></span>

## 特殊字符

| 字符 | 描述 |
| --- | --- |
| - | 范围符 |
| ( ) | 标记一个子表达式的开始和结束位置 |
| [ ] | 中括号中的任一字符匹配则算满足条件 |
| { } | 标记限定符表达式，表示重复次数 |
| ^ | 在方括号中使用时，表示不接受该方括号表达式中的字符集合 |
| ? | 指明一个非贪婪限定符 |
| \\ | 将下一个字符标记为或特殊字符；或原义字符；或向后引用；或八进制转义符 |
| \| | 指明两项之间的一个选择 |
| . | 匹配除换行符 \n 之外的任何单字符 |

---

<span id="jump5"></span>

## 限定符

| 字符 | 描述 |
| --- | --- |
| ? | 匹配前面的子表达式零次或一次 |
| * | 匹配前面的子表达式零次或多次 |
| + | 匹配前面的子表达式一次或多次 |
| {n} | n是一个非负整数。匹配确定的 n 次 |
| {n,} | n 是一个非负整数。至少匹配n 次 |
| {n,m} | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次 |

**注意**：中间不要有空格

### 贪婪匹配

上述限定符中除了```{n}```，其他都是贪婪的，贪婪匹配特征是一次性读入整个字符串经行匹配

每当不匹配就舍弃最右边一个字符，继续匹配

依次匹配和舍弃，直到匹配成功或者把整个字符串舍弃为止

通俗点讲，就是看到想要的，有多少就捡多少，除非再也没有想要的了

例如：

```javascript
// 源字符串：
aa<div>test1</div>bb<div>test2</div>cc
// 正则表达式一：
<div>.*</div> 

// 匹配结果一：
<div>test1</div>bb<div>test2</div> 
```

### 非贪婪匹配

只要在限定符的后面加上一个```?```就可以实现非贪婪匹配

非贪婪模式，就是在整个表达式匹配成功的前提下，尽可能少的匹配

通俗点讲，就是找到一个想要的捡起来就行了，至于还有没有没捡的就不管了

```javascript
// 源字符串：
aa<div>test1</div>bb<div>test2</div>cc
// 正则表达式二：
<div>.*?</div> 

// 匹配结果二：
<div>test1</div> 
```

---

<span id="jump6"></span>

## 定位符

| 字符 | 描述 |
| --- | --- |
| ^ | 匹配输入字符串开始的位置 |
| $ | 匹配输入字符串结尾的位置 |
| \b | 匹配一个单词边界，即字与空格间的位置 |
| \B | 非单词边界匹配 |

**注意：**

1. 如果是^abc$，表示只能是abc，abcabc也不行

2. 由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不能将限定符与定位符一起使用

### \b

\b 字符的位置是非常重要的

如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项

例如，下面的表达式匹配```aptitude```中的字符串```apt```，但不匹配```Chapter```中的字符串```apt```：

```javascript
/\bapt/
```

如果它位于字符串的结尾，它在单词的结尾处查找匹配项

例如，下面的表达式匹配单词```Chapter```中的字符串```ter```

```javascript
/ter\b/
```

---

<span id="jump7"></span>

## ?=、?<=、?!、?<!=的使用区别

### ?=

```exp1(?=exp2)```：查找 exp2 前面的 exp1

### ?<=

```(?<=exp2)exp1```：查找 exp2 后面的 exp1

### ?!

```exp1(?!exp2)```：查找后面不是 exp2 的 exp1

### ?<!=

```(?<!=exp2)exp1```：查找前面不是 exp2 的 exp1

---

<span id="jump8"></span>

## 反向引用

### 捕获分组

对一个正则表达式模式或部分模式两边添加圆括号，将导致相关匹配存储到一个临时缓冲区中

所捕获的每个子匹配，都按照在正则表达式模式中从左到右出现的顺序存储

缓冲区编号从```1```开始，每个缓冲区都可以使用```\n```访问

可以使用非捕获元字符```?:```、```?=```或```?!```来重写捕获，忽略对相关匹配的保存

### RegExp.$xx

RegExp这个对象会在我们调用了正则表达式的方法后, 自动将最近一次的结果保存在里面

所以如果我们在使用正则表达式时, 有用到分组，那么就可以直接在调用完以后直接使用RegExp.$xx来使用捕获到的分组内容

### 找出连续相同的值

例如，在正则```(.+)\1```中，```\1```等于```(.+)```中匹配到的值，也就是连续2次相同的值

同理，```(.+)\1\1```则是查找连续三次相同

### 将通用资源指示符 (URI) 分解为其组件

假定您想将下面的 URI 分解为协议（ftp、http 等等）、域地址和页/路径：

```javascript
http://www.runoob.com:80/html/html-tutorial.html
```

下面的正则表达式提供该功能：

```javascript
let str = "http://www.runoob.com:80/html/html-tutorial.html";
let patt1 = /(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/;
let arr = str.match(patt1);
for (let i = 0; i < arr.length ; i++) {
    document.write(arr[i]);
    document.write("<br>");
}
```

第三行代码 str.match(patt1) 返回一个数组，实例中的数组包含 5 个元素，索引 0 对应的是整个字符串，索引 1 对应第一个匹配符（括号内），以此类推。

第一个括号子表达式捕获 Web 地址的协议部分。该子表达式匹配在冒号和两个正斜杠前面的任何单词。

第二个括号子表达式捕获地址的域地址部分。子表达式匹配非 : 和 / 之后的一个或多个字符。

第三个括号子表达式捕获端口号（如果指定了的话）。该子表达式匹配冒号后面的零个或多个数字。只能重复一次该子表达式。

最后，第四个括号子表达式捕获 Web 地址指定的路径和 / 或页信息。该子表达式能匹配不包括 # 或空格字符的任何字符序列。

---

<span id="jump9"></span>

## 修饰符（标记）

标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略

标记不写在正则表达式里，标记位于表达式之外，格式如下：

```javascript
/pattern/flags
```

| 修饰符 | 描述 |
| --- | --- |
| i | ignore - 不区分大小写 |
| g | global - 全局匹配，查找所有的匹配项 |
| m | more - 多行匹配，g 只匹配第一行，添加 m 之后实现多行 |

---

<span id="jump10"></span>

## 运算符优先级

正则表达式从左到右进行计算，并遵循优先级顺序

下表从最高到最低说明了各种正则表达式运算符的优先级顺序：


| 运算符 | 描述 |
| --- | --- |
| \\ | 转义符 |
| (), [] | 圆括号和方括号 |
| ^, $, \任何元字符、任何字符 | 定位点和序列（即：位置和顺序） |
| \| | "或"操作 |

---

<span id="jump11"></span>

## 正则表达式中的替换

### replace方法

可以实现字符串替换操作，同样也可以是正则表达式，返回值是一个新字符串

```javascript
字符串.replace(正则表达式或字符串, 替换成的字符串)

```

### 应用场景

屏蔽敏感词，例如：

```javascript
div.innerHTML = text.value.replace(/激情|gay/g, '**'); // 将所有的“激情”和“gay”都换成“**”
```
