# 闭包

## 目录

[概念](#jump1)

[闭包的作用](#jump2)

[闭包的实现](#jump3)

[闭包的原理](#jump4)

---	

<span id="jump1"></span>

## 概念

闭包就是由函数创造的一个词法作用域，里面创建的变量被引用后，可以在这个词法环境之外自由使用

当一个函数持有外部环境的变量时，就形成了闭包

```javascript
let a = 1
let b = function(){
    console.log(a)
}
```

在这个例子里函数b因为捕获了外部作用域（环境）中的变量a，因此形成了闭包

而由于变量a并不属于函数b，所以在概念里被称之为「自由变量」

---

<span id="jump2"></span>

## 闭包的作用

闭包通常用来创建内部变量，使得这些变量不能被外部随意修改

同时又可以通过指定的函数接口来操作

---

<span id="jump3"></span>

## 闭包的实现

最常见的实现方式就是函数包函数

被包的函数中使用了包裹函数的变量

然后return被包的函数

例如：

```javascript
function foo(){
  var local = 1
  function bar(){
    local++
    return local
  }
  return bar
}
```

上述例子中，bar与local就形成了闭包

---

<span id="jump4"></span>

## 闭包的原理

### Scope

每一个函数都有一个隐藏的属性[[Scope]]，这个属性保存着函数的作用域链，它本质上是一个集合

### 当一个函数没有父函数

#### 创建函数时

[[Scope]]属性的第一个值会引用当前的全局上下文

所有全局变量及其存储的数据都在这个集合里

```javascript
[
(Global Context)
]
```

#### 调用函数时

当一个函数被调用的时候，会创建一个Execute context，即运行时上下文

它存储调用该函数的对象，函数的参数数组，函数的局部变量（值还未定义）

该集合会被压入[[Scope]]属性，此时[[Scope]]属性如下：

```javascript
[
(Execute context),
(Global Context)
]
```

#### 函数return时

引擎只是去除[[Scope]]属性中对运行时上下文的引用，并没有立即销毁它

此时运行时上下文没有任何引用了，在将来的某个时刻会被垃圾收集器销毁

此时[[Scope]]属性如下：

```javascript
[
(Global Context)
]
```

### 如果一个函数创建的时候存在父函数

#### 创建函数时

当一个子函数被创建时，显然，这个创建是父函数的执行导致的

所以当子函数创建时，父函数已经处于执行阶段，所以父函数的执行上下文已经创建了

子函数在创建的时候，除了要引用全局上下文，也需要引用父函数的执行上下文

否则子函数就无法访问父函数的局部变量，违背了设计的要求

此时两个函数的[[Scope]]属性如下：

父函数：

```javascript
[
(Father Execute Context),
(Global Context)
]
```

子函数：

```javascript
[
(Father Execute Context), // 这里引用的是父函数的执行上下文，自身的执行上下文此时还未创建。
(Global Context)
]
```

#### 调用函数时

当一个子函数执行时，因为它同样是函数，所以它同样需要创建自己的执行上下文

此时子函数的[[Scope]]属性如下：

```javascript
[
(Child Execute Context), // 这是子函数自己的执行上下文
(Father Execute Context), // 这里引用的是父函数的执行上下文
(Global Context)
]
```

#### 函数return时

只解除[[Scope]]属性中对自身执行上下文的引用，对父函数的执行上下文的引用并没有解除

此时子函数的[[Scope]]属性如下：

```javascript
[
(Father Execute Context), // 这里引用的是父函数的执行上下文
(Global Context)
]
```

### 所以，为什么父函数的局部变量没有被销毁？

因为它们所在的执行上下文还被子函数的[[Scope]]属性引用着

只要子函数还存在引用，垃圾收集器就不会销毁它们所在的执行上下文

因为父函数的局部变量并不在全局上下文中，所以它只能在子函数的变量解析中被访问，自然而然就相当于它们是子函数私有的了