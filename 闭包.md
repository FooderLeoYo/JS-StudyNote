# 闭包

## 目录

[概念](#jump1)

[闭包的作用](#jump2)

[闭包的实现](#jump3)

[闭包的原理](#jump4)

---	

<span id="jump1"></span>

## 概念

闭包就是由函数创造的一个词法作用域，里面创建的变量被引用后，可以在这个词法环境之外自由使用

更通俗地说，当一个函数能够读取其他函数的内部变量，就发生了闭包

```javascript
let a = 1
let b = function(){
    console.log(a)
}
```

在这个例子里函数b因为捕获了外部作用域（环境）中的变量a，因此形成了闭包

而由于变量a并不属于函数b，所以在概念里被称之为「自由变量」

---

<span id="jump2"></span>

## 闭包的作用

闭包通常用来创建内部变量，使得这些变量不能被外部随意修改，同时又可以通过指定的函数接口来操作

另一个就是让这些变量的值始终保持在内存中

---

<span id="jump3"></span>

## 闭包的实现

### 常见的实现方法

最常见的实现方式就是函数包函数

被包的函数中使用了包裹函数的变量

然后return被包的函数

### 例子

```javascript
let nAdd = () => n+=1
let f1 = () => {
  let n = 999;
  let f2 = () => alert(n);

  return f2;
}

let result=f1();
result(); // 999
nAdd();
result(); // 1000
```

上述例子中，f1与f2就形成了闭包

### 闭包引用的局部变量不会马上被回收

在上述例子中，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除

原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制回收

---

<span id="jump4"></span>

## 闭包的原理

### Scope

每一个函数都有一个隐藏的属性[[Scope]]，这个属性保存着函数的作用域链，它本质上是一个集合

### 当一个函数没有父函数

#### 创建函数时

[[Scope]]属性的第一个值会引用当前的全局上下文

所有全局变量及其存储的数据都在这个集合里

```javascript
[
(Global Context)
]
```

#### 调用函数时

当一个函数被调用的时候，会创建一个Execute context，即运行时上下文

它存储调用该函数的对象，函数的参数数组，函数的局部变量（值还未定义）

该集合会被压入[[Scope]]属性，此时[[Scope]]属性如下：

```javascript
[
(Execute context),
(Global Context)
]
```

#### 函数return时

引擎只是去除[[Scope]]属性中对运行时上下文的引用，并没有立即销毁它

此时运行时上下文没有任何引用了，在将来的某个时刻会被垃圾收集器销毁

此时[[Scope]]属性如下：

```javascript
[
(Global Context)
]
```

### 如果一个函数创建的时候存在父函数

#### 创建函数时

当一个子函数被创建时，显然，这个创建是父函数的执行导致的

所以当子函数创建时，父函数已经处于执行阶段，所以父函数的执行上下文已经创建了

子函数在创建的时候，除了要引用全局上下文，也需要引用父函数的执行上下文

否则子函数就无法访问父函数的局部变量，违背了设计的要求

此时两个函数的[[Scope]]属性如下：

父函数：

```javascript
[
(Father Execute Context),
(Global Context)
]
```

子函数：

```javascript
[
(Father Execute Context), // 这里引用的是父函数的执行上下文，自身的执行上下文此时还未创建。
(Global Context)
]
```

#### 调用函数时

当一个子函数执行时，因为它同样是函数，所以它同样需要创建自己的执行上下文

此时子函数的[[Scope]]属性如下：

```javascript
[
(Child Execute Context), // 这是子函数自己的执行上下文
(Father Execute Context), // 这里引用的是父函数的执行上下文
(Global Context)
]
```

#### 函数return时

只解除[[Scope]]属性中对自身执行上下文的引用，对父函数的执行上下文的引用并没有解除

此时子函数的[[Scope]]属性如下：

```javascript
[
(Father Execute Context), // 这里引用的是父函数的执行上下文
(Global Context)
]
```

### 所以，为什么父函数的局部变量没有被销毁？

因为它们所在的执行上下文还被子函数的[[Scope]]属性引用着

只要子函数还存在引用，垃圾收集器就不会销毁它们所在的执行上下文

因为父函数的局部变量并不在全局上下文中，所以它只能在子函数的变量解析中被访问，自然而然就相当于它们是子函数私有的了
