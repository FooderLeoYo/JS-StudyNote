# 原型和继承

## 目录

[为什么需要原型](#jump1)

[几个重要的规则](#jump2)

[原型对象：prototype](#jump3)

[对象的原型：__proto__](#jump4)

[构造函数：constructor](#jump5)

[原型链](#jump6)

[继承](#jump7)

[扩展内置对象](#jump8)

---

<span id="jump1"></span>

## 为什么需要原型

同一个类的不同对象中会有相同的方法，例如：ldh和zxy都是类Star的对象实例，它们中有共同的方法ldh.sing和zxy.sing

但创建对象实例时，构造函数并不会复用这些方法而是分别开辟内存空间

因此可以把那些不变的方法直接定义在类的构造函数的prototype对象上，这样所有这个类的对象实例就可以共享这些方法
		
---

<span id="jump2"></span>

## 几个重要的规则

### 4个概念

1. js分为函数对象和普通对象，每个对象都有__proto__属性，但是只有函数对象才有prototype属性

2. Object、Function都是js内置的函数, 类似的还有我们常用到的Array、RegExp、Date、Boolean、Number、String

3. 属性__proto__是一个对象，它有两个属性，constructor和__proto__

4. 原型对象prototype有一个默认的constructor属性，用于记录实例是由哪个构造函数创建

### 2个准则

1. 原型对象（即Person.prototype）的constructor指向构造函数本身

2. 对象的实例（即person01）的__proto__和原型对象指向同一个地方

---	

<span id="jump3"></span>

## 原型对象：prototype

### 概念

prototype属性可以看成是一块特殊的存储空间，存储了供“徒弟”、“徒孙”们使用的方法和属性

prototype是构造函数默认生成的一个内置对象，它是函数独有的属性

prototype设计之初就是为了实现继承，让某一个构造函数实例化的所有对象可以找到公共的方法和属性

有了prototype我们不需要为每一个实例创建重复的属性方法，而是将属性方法创建在构造函数的原型对象上，那些不需要共享的才创建在构造函数中

### 各级prototype的指向

![指向](https://raw.githubusercontent.com/FooderLeoYo/JS-StudyNote/master/assets/imgs/prototype.png)

### 定义公共属性与公共方法的区别
	
一般情况下，我们的公共属性定义到构造函数里面

公共的方法我们放到原型对象身上

例子：

```javascript
Star.prototype.sing = function() {
  console.log('我会唱歌');
}
```

---

<span id="jump4"></span>

## 对象的原型：__proto__

### 概念

让“徒弟”、“徒孙” 们找到自己“师父”、“师父的师父” 提供给自己的方法和属性

对象实例身上有一个```__proto__```，它的含义就是告诉我们一个对象的原型对象是谁

构造函数的原型对象上的属性和方法就是通过```__proto__```属性，才能与构造函数的实例联系在一起的

```__proto__```属性相当于通往```prototype```唯一的路（指针）

### 查找一个方法的顺序

以类```Star```的```ldh```实例举例：

首先先看```ldh```对象身上是否有```sing```方法，如果有就执行```ldh```上的```sing```

如果没有```sing```这个方法，因为有```__proto__```的存在，就会去```prototype```上查找```sing```

### prototype和__proto__中的constructor属性

如果修改了原来的```prototype```，且给```prototype```赋值的是一个对象

则必须手动的利用```constructor```指回原来的构造函数

### 各级__proto__的指向

![指向](https://github.com/FooderLeoYo/JS-StudyNote/blob/master/assets/imgs/__protyo__.png?raw=true)

---

<span id="jump5"></span>

## 构造函数：constructor

### 概念

constructor属性是让“徒弟”、“徒孙” 们知道是谁创造了自己

constructor是对象才有的属性，它是从一个对象指向一个函数的，指向的函数就是该对象的构造函数

构造函数的constructor指向Function，Function的constructor指回自己，因为Function就是根构造函数

### 各级constructor的指向

![指向](https://github.com/FooderLeoYo/JS-StudyNote/blob/master/assets/imgs/constructor.png?raw=true)

---

<span id="jump6"></span>

## 原型链

### 图示

原型链上各个对象间的关系及指向如下图所示：

![完整的原型链](https://raw.githubusercontent.com/FooderLeoYo/JS-StudyNote/master/assets/imgs/%E5%AE%8C%E6%95%B4%E5%8E%9F%E5%9E%8B%E9%93%BE.png)

（原始手绘笔记，不舍得删(o￣ヘ￣o)）

```
							    -----------  
							   |           |
							   |   null    |
							   |           |
							    -----------
							    /\
           通过Object原型对象Object.prototype.__proto__指向/
	                                                  / 
							 /
       -----------       通过Object.prototype指向        -----------                       
      |	          |------------------------------------>|  Object   |
      |  Object   |<------------------------------------|  原型对象 |
      |  构造函数 |  通过Object.prototye.consructor指回 | prototype |
       -----------			    	         -----------  
						       /\
	   通过Stra原型对象Star.prototye.__proto__指向/
	                                             / 
						    /
    -----------      通过Start.prototype指向        -----------                       
   |           |---------------------------------->|   Star    |
   |  构造函数 |<----------------------------------|  原型对象 |
   |   Star    |  通过Star.prototye.consructor指回 | prototype |
    -----------	  __			            -----------  
	        \ \			          /\
        通过调用 \ \ 		                 /
         Star创建 \ \ 通过ldh.consructor指回    / 通过ldh.__proto__指向
		   \ \			       /
		    \ \	     -----------      /
		  __ \ \    |           |    /
			    |    ldh    |
			    |  对象实例 |
			     -----------
```

即当访问一个对象的属性（方法）时，按照：

```
对象自身——>对象的原型对象——>Object的原型对象——>null
```

由上图还可以得知，其他内置函数对象的原型对象（例如：```Array.prototype```）和自定义构造函数的```__proto__```都指向```Object.prototype```, 因为原型对象```prototype```本身是普通对象

---

<span id="jump7"></span>

## 继承

ES6之前没有extends，因此只能通过构造函数+原型对象模拟实现继承，被称为组合继承

### call()

例如：

```javascript
fun.call(需要指向的对象, 参数1, 参数2, ...)
```

然后调用函数fun，并且修改函数运行时的this指向

### 借用父构造函数继承属性

#### 核心原理

通过call()把父类型的this指向子类型的this，实现子类型继承父类型的属性

#### 例子

```javascript
// 1. 父构造函数
function Father(uname, age) {
    // this 指向父构造函数的对象实例
    this.uname = uname;
    this.age = age;
}

// 2 .子构造函数 
function Son(uname, age) {
    // this 指向子构造函数的对象实例
    Father.call(this, uname, age);
}

var son = new Son('刘德华', 18);
```

### 借用原型对象继承方法

#### 核心原理

将子类型的原型指向一个新建的父类型对象实例

再将子类型原型的constructor指回子类型

#### 例子

```javascript
Son.prototype = new Father();
Son.prototype.constructor = Son;
```

---

<span id="jump8"></span>

## 扩展内置对象

可以通过原型对象，对原来的内置对象进行扩展自定义的方法

注意，不能给原型对象覆盖操作：

```javascript
Array.prototype = {xx: function() {}}
```

只能是：

```javascript
Array.prototype.xx = function() {}

```
