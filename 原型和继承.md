# 原型和继承

## 目录

[为什么需要原型](#jump1)

[几个重要的规则](#jump2)

[原型对象：prototype](#jump3)

[对象的原型：__proto__](#jump4)

[构造函数：constructor](#jump5)

[原型链](#jump6)

[继承](#jump7)

[扩展内置对象](#jump8)

---

<span id="jump1"></span>

## 为什么需要原型

### JS中的继承

当谈到继承时，JavaScript中只有一种结构：原型继承

不同于基于类的语言 (如 Java 或 C++)，JavaScript是动态的，并且本身不提供一个 class 实现

虽然在 ES2015/ES6 中引入了 class 关键字，但那只是语法糖，JavaScript 仍然是基于原型的

### 方法复用

同一个类的不同对象中会有相同的方法，例如：ldh和zxy都是类Star的对象实例，它们中有共同的方法ldh.sing和zxy.sing

但创建对象实例时，构造函数并不会复用这些方法而是分别开辟内存空间

因此可以把那些不变的方法直接定义在类的构造函数的prototype对象上，这样所有这个类的对象实例就可以共享这些方法

### 为父类添加新的方法

父类已经声明好后，当需要为父类添加新的方法时，由于其不是一个实例对象，因此不能直接通过```.新方法名```添加

这时就只能通过```父类.prototype.新方法名 = 表达式```的方式来添加

* 这里只提方法是因为，父类的公共属性一般写在构造函数里，而不是prototype中
		
---

<span id="jump2"></span>

## 几个重要的规则

- prototype属性是函数独有的

- ```__proto__```、 constructor属性是对象所独有的

- 函数也是对象的一种，那么函数同样也有属性__proto__、 constructor

- 一般情况下，父类的公共属性定义到constructor里面，公共的方法我们放到prototype身上

- prototype有一个默认的constructor属性，用于记录实例是由哪个构造函数创建

- prototype的constructor指向构造函数本身

- 属性__proto__是一个对象，它有两个属性，constructor和__proto__

- ```__proto__```和prototype指向同一个地方

---	

<span id="jump3"></span>

## 原型对象：prototype

### 概念

prototype属性可以看成是一块特殊的存储空间，存储了供“徒弟”、“徒孙”们使用的方法（属性放在构造函数中）

prototype是构造函数默认生成的一个内置对象，它是函数独有的属性

prototype设计之初就是为了实现继承，让某一个构造函数实例化的所有对象可以找到公共的方法

有了prototype我们不需要为每一个实例创建重复的方法，而是将方法创建在构造函数的原型对象上，那些不需要共享的才创建在构造函数中

### 各级prototype的指向

![指向](https://raw.githubusercontent.com/FooderLeoYo/JS-StudyNote/master/assets/imgs/prototype.png)

### 定义公共属性与公共方法的区别
	
一般情况下，父类的公共属性定义到constructor里面

公共的方法我们放到prototype身上

例子：

```javascript
function Star() {
  this.name = "ldh";
}
Star.prototype.sing = function() {
  console.log('我会唱歌');
}
```

---

<span id="jump4"></span>

## 对象的原型：__proto__

### 概念

让“徒弟”、“徒孙” 们找到自己“师父”、“师父的师父” 提供给自己的方法和属性，追溯到头就是null

对象实例身上有一个```__proto__```，它的含义就是告诉我们一个对象的原型对象是谁

构造函数的原型对象上的属性和方法就是通过```__proto__```属性，才能与构造函数的实例联系在一起的

```__proto__```属性相当于通往```prototype```唯一的路（指针）

### 各级__proto__的指向

![指向](https://github.com/FooderLeoYo/JS-StudyNote/blob/master/assets/imgs/__protyo__.png?raw=true)

---

<span id="jump5"></span>

## 构造函数：constructor

### 概念

constructor属性是让“徒弟”、“徒孙” 们知道是谁创造了自己，相当于获取自己的父母，追溯到头就是Function()

constructor是对象才有的属性，它是从一个对象指向一个函数的，指向的函数就是该对象的构造函数

构造函数的constructor指向Function，Function的constructor指回自己，因为Function就是根构造函数

### 各级constructor的指向

![指向](https://github.com/FooderLeoYo/JS-StudyNote/blob/master/assets/imgs/constructor.png?raw=true)

---

<span id="jump6"></span>

## 原型链

### 概念

当试图引用对象(实例instance)的某个属性时，程序会首先在对象内部寻找该属性，如果找不到则会去该对象的原型(instance.prototype)里去找这个属性

如果instance.prototype中还是没有，此时程序不会灰心，它会继续在instance.prototype.__proto__中寻找……直至Object的原型对象

这种搜索的轨迹形似一条长链，又因原型在这个规则中充当了链接的作用，于是我们把这种实例与原型的链条称作```原型链```

### 图示

原型链上各个对象间的关系及指向如下图所示：

![完整的原型链](https://raw.githubusercontent.com/FooderLeoYo/JS-StudyNote/master/assets/imgs/%E5%AE%8C%E6%95%B4%E5%8E%9F%E5%9E%8B%E9%93%BE.png)

（原始手绘笔记，不舍得删(o￣ヘ￣o)）

```
							    -----------  
							   |           |
							   |   null    |
							   |           |
							    -----------
							    /\
           通过Object原型对象Object.prototype.__proto__指向/
	                                                  / 
							 /
       -----------       通过Object.prototype指向        -----------                       
      |	          |------------------------------------>|  Object   |
      |  Object   |<------------------------------------|  原型对象 |
      |  构造函数 |  通过Object.prototye.consructor指回 | prototype |
       -----------			    	         -----------  
						       /\
	   通过Stra原型对象Star.prototye.__proto__指向/
	                                             / 
						    /
    -----------      通过Start.prototype指向        -----------                       
   |           |---------------------------------->|   Star    |
   |  构造函数 |<----------------------------------|  原型对象 |
   |   Star    |  通过Star.prototye.consructor指回 | prototype |
    -----------	  __			            -----------  
	        \ \			          /\
        通过调用 \ \ 		                 /
         Star创建 \ \ 通过ldh.consructor指回    / 通过ldh.__proto__指向
		   \ \			       /
		    \ \	     -----------      /
		  __ \ \    |           |    /
			    |    ldh    |
			    |  对象实例 |
			     -----------
```

### 寻找的顺序

当访问一个对象的属性（方法）时，按照：

```
对象自身——>对象的原型对象——>Object的原型对象——>null
```

例如：

当我们调用p1.toString()的时候，先在p1对象本身寻找，没有找到则通过p1.__proto__找到了原型对象Parent.prototype，也没有找到，又通过Parent.prototype.__proto__找到了上一层原型对象Object.prototype，在这一层找到了toString方法，则返回该方法供p1使用

如果找到Object.prototype上也没找到，就在Object.prototype.__proto__中寻找，但是Object.prototype.__proto__ === null，所以就返回undefined

---

<span id="jump7"></span>

## 继承

### 借用父构造函数继承属性

#### 核心原理

在子构造函数中，调用父构造函数并通过call()把父类型的this指向子类型的this

#### 例子

```javascript
// 1. 父构造函数
function Father(uname, age) {
    // this 指向父构造函数的对象实例
    this.uname = uname;
    this.age = age;
}

// 2 .子构造函数 
function Son(uname, age) {
    // this 指向子构造函数的对象实例
    Father.call(this, uname, age);
}

var son = new Son('刘德华', 18);
```

#### 缺点

- 只能继承父类的实例属性和方法，不能继承父类原型的属性和方法

- 无法实现复用，每个子类都有父类实例函数的副本，影响性能

### 借用原型对象继承方法

#### 核心原理

将子类型的原型指向一个新建的父类型对象实例

再将子类型原型的constructor指回子类型

#### 例子

```javascript
Son.prototype = new Father();
Son.prototype.constructor = Son;
```

#### 缺点

创建多个子实例时，父类型实例的属性会被篡改

```javascript
function SuperType(){
  this.colors = ["red", "blue", "green"];
}
function SubType(){}

SubType.prototype = new SuperType();

let instance1 = new SubType();
instance1.colors.push("black");
alert(instance1.colors); //"red,blue,green,black"

let instance2 = new SubType(); 
alert(instance2.colors); //"red,blue,green,black"
```

### 组合继承

#### 原理

用原型链实现对原型属性和方法的继承，用借用构造函数来实现实例属性的继承

#### 例子

```javascript
function SuperType(name){
  this.name = name;
  this.colors = ["red", "blue", "green"];
}
SuperType.prototype.sayName = function(){
  alert(this.name);
};

function SubType(name, age){
  // 继承父类实例属性
  // 第二次调用SuperType()
  SuperType.call(this, name);
  this.age = age;
}

// 继承父类原型方法
// 第一次调用SuperType()
SubType.prototype = new SuperType(); 
SubType.prototype.constructor = SubType; 
SubType.prototype.sayAge = function(){
    alert(this.age);
};

var instance1 = new SubType("Nicholas", 29);
instance1.colors.push("black");
alert(instance1.colors); //"red,blue,green,black"
instance1.sayName(); //"Nicholas";
instance1.sayAge(); //29

var instance2 = new SubType("Greg", 27);
alert(instance2.colors); //"red,blue,green"
instance2.sayName(); //"Greg";
instance2.sayAge(); //27
```

#### 缺点

原型链中会存在两份相同的属性/方法

分析：

第一次调用SuperType()：给SubType.prototype写入两个属性name，color

第二次调用SuperType()：给instance1写入两个属性name，color

SubType.prototype的两个同名属性就造成了存储空间的浪费

而之所以不会冲突，是由于找到了就不会继续搜寻原型链，因此实例对象instance1上的两个属性相当于屏蔽掉了其原型对象SubType.prototype的两个同名属性

### 寄生组合式继承

#### 原理

```javascript
// 父类初始化属性和原型上的方法
function SuperType(name){
  this.name = name;
  this.colors = ["red", "blue", "green"];
}
SuperType.prototype.sayName = function(){
  alert(this.name);
};

// 子类初始化属性和原型上的方法
function SubType(name, age){
  // 实现继承属性（支持传参和避免篡改）
  SuperType.call(this, name);
  this.age = age;
}
SubType.prototype.sayAge = function(){
  alert(this.age);
}

// 实现继承方法
function inheritPrototype(subType, superType){
  // 创建对象，创建父类原型（而不是父类实例）的一个副本，也是区别于前一种组合继承的关键所在
  let prototype = Object.create(superType.prototype); 
  // 增强对象，弥补因重写原型而失去的默认的constructor属性
  prototype.constructor = subType;                    
  // 指定对象，将新创建的对象赋值给子类的原型
  subType.prototype = prototype;                      
}
// 子类继承父类原型上的方法
inheritPrototype(SubType, SuperType);

let instance1 = new SubType("xyc", 23);
let instance2 = new SubType("lxy", 23);
instance1.colors.push("2"); // ["red", "blue", "green", "2"]
instance1.colors.push("3"); // ["red", "blue", "green", "3"]
```

相较于前一种组合继承，只调用了一次SuperType 构造函数，因为这里将子类的prototype指向父类的prototype而不是一个新建的父类的实例

因此在继承了前一种组合继承的优点的基础上，避免了在SubType.prototype上创建不必要的、多余的属性

于此同时，原型链还能保持不变，因此，还能够正常使用instanceof和isPrototypeOf()

这是最成熟的方法，也是现在库所采用的方法

#### 应用实例：继承多个父类

```javascript
function MyClass() {
  // 继承父类们的属性
  SuperClass.call(this);
  OtherSuperClass.call(this);
}

// 继承一个父类的方法
MyClass.prototype = Object.create(SuperClass.prototype);
// 继续继承其它父类的方法
Object.assign(MyClass.prototype, OtherSuperClass.prototype);
// constructor指回子类构造函数
MyClass.prototype.constructor = MyClass;
// 添加子类原型上的方法
MyClass.prototype.myMethod = function() {
   // do something
};
```

---

<span id="jump8"></span>

## 扩展内置对象

可以通过原型对象，对原来的内置对象进行扩展自定义的方法

注意，不能给原型对象覆盖操作：

```javascript
Array.prototype = {xx: function() {}}
```

只能是：

```javascript
Array.prototype.xx = function() {}
```
