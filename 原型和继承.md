# 原型和继承

## 目录

[为什么需要原型](#jump1)

[原型对象prototype](#jump2)

[对象原型__proto__](#jump3)

[原型链](#jump4)

[扩展内置对象](#jump5)

[](#jump5)

[](#jump5)

---	

<span id="jump1"></span>

## 为什么需要原型

同一个类的不同对象中会有相同的方法

例如：ldh和zxy都是类Star的对象实例，它们中有共同的方法ldh.sing和zxy.sing

但创建对象实例时，构造函数并不会复用这些方法而是分别开辟内存空间

因此可以把那些不变的方法直接定义在类的构造函数的prototype对象上

这样所有这个类的对象实例就可以共享这些方法
		
---

<span id="jump2"></span>

## 原型对象prototype

### 概念

```prototype```是构造函数默认生成的一个内置对象，其作用是共享方法

### 定义公共属性与公共方法的区别
	
一般情况下，我们的公共属性定义到构造函数里面

公共的方法我们放到原型对象身上

例子：

```javascript
Star.prototype.sing = function() {
  console.log('我会唱歌');
}
```

---

<span id="jump3"></span>

## 对象原型__proto__

### 概念

对象实例身上有一个```__proto__```，它指向构造函数的原型对象```prototype```

### 查找一个方法的顺序

以类```Star```的```ldh```实例举例：

首先先看```ldh```对象身上是否有```sing```方法，如果有就执行```ldh```上的```sing```

如果没有```sing```这个方法，因为有```__proto__```的存在，就会去```prototype```上查找```sing```

### prototype和__proto__中的constructor属性

如果修改了原来的```prototype```，且给```prototype```赋值的是一个对象

则必须手动的利用```constructor```指回原来的构造函数

---

<span id="jump4"></span>

## 原型链

原型链上各个对象间的关系及指向如下图所示：

							       -----------  
							      |           |
							      |   null    |
							      |           |
							       -----------
								  /\
								 /
								/ 通过Object原型对象Object.prototype.__proto__指向
							       /
	    -----------       通过Object.prototype指向        -----------                       
	   |	       |------------------------------------>|  Object   |
	   |  Object   |<------------------------------------|  原型对象 |
	   |  构造函数 |  通过Object.prototye.consructor指回 | prototype |
	    -----------			    	              -----------  
							     /\
							    /
							   / 通过Stra原型对象Star.prototye.__proto__指向
							  /
    -----------      通过Start.prototype指向        -----------                       
   |           |---------------------------------->|   Star    |
   |  构造函数 |<----------------------------------|  原型对象 |
   |   Star    |  通过Star.prototye.consructor指回 | prototype |
    -----------				            -----------  
	         \				  /\
         通过调用 \				 /
	  Star创建 \			        / 通过ldh.__proto__指向
		    \			       /
		     \	     -----------      /
		      \/    |           |    /
			    |    ldh    |
			    |  对象实例 |
			     -----------

即当访问一个对象的属性（方法）时，按照：

```
对象自身——>对象的原型对象——>Object的原型对象——>null
```

---

<span id="jump5"></span>

## 扩展内置对象

可以通过原型对象，对原来的内置对象进行扩展自定义的方法

注意，不能给原型对象覆盖操作：

```javascript
Array.prototype = {xx: function() {}}
```

只能是：

```javascript
Array.prototype.xx = function() {}

```


---

<span id="jump6"></span>

## 继承

ES6之前没有extends，因此只能通过构造函数+原型对象模拟实现继承，被称为组合继承

### call()

例如：

```javascript
fun.call(需要指向的对象, 参数1, 参数2, ...)
```

然后调用函数fun，并且修改函数运行时的this指向

### 借用父构造函数继承属性

#### 核心原理

通过call()把父类型的this指向子类型的this，实现子类型继承父类型的属性

#### 例子

```javascript
// 1. 父构造函数
function Father(uname, age) {
    // this 指向父构造函数的对象实例
    this.uname = uname;
    this.age = age;
}

// 2 .子构造函数 
function Son(uname, age) {
    // this 指向子构造函数的对象实例
    Father.call(this, uname, age);
}

var son = new Son('刘德华', 18);
```

### 借用原型对象继承方法

#### 核心原理

将子类型的原型指向一个新建的父类型对象实例

再将子类型原型的constructor指回子类型

#### 例子

```javascript
Son.prototype = new Father();
Son.prototype.constructor = Son;
```
