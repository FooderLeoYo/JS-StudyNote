# 函数

## 目录

[Execution context](#jump1)

[Execution stack](#jump2)

[变量对象](#jump3)

[Scope](#jump4)

[Scope Chain](#jump5)

[this](#jump6)

[JS程序执行的流程](#jump7)

[](#jump)

---	

<span id="jump1"></span>

## Execution context

### 定义

当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)
 
对于每个执行上下文，都有三个重要属性：

- 变量对象(Variable object，VO)

- 作用域链(Scope chain)

- this

### 分类

#### Global execution context

Any code that is not inside a function is in the global context

It will perform two things: create a global window object (in the case of a browser), and set the value of ```this``` equal to this global object

In a program, there will only be one global execution context 

#### Function Execution Context

Whenever a function is called, a new context will be created for this function

#### Eval Function Execution Context

开发者并不经常使用 eval，所以在这里不再讨论

---

<span id="jump2"></span>

## Execution stack

Also known as “call stack” 

It is used to store all execution contexts created when the code is run

JS is single-threaded and can only do one thing at a time, and other things will be queued in the specified context stack for execution

When the JavaScript engine encounters your script for the first time, it creates a global execution context and pushes it onto the current execution stack

Whenever the engine encounters a function call, it creates a new execution context for the function and pushes it to the top of the stack

The engine will execute those functions whose execution context is at the top of the stack. When the execution of the function ends, the execution context is popped from the stack, and the control flow reaches the next context in the current stack

---

<span id="jump3"></span>

## 变量对象



---

<span id="jump4"></span>

## Scope

### 定义

The current context of execution

Scope likes an independent territory so that variables will not be leaked or exposed

The role of scope is to isolate variables, and variables with the same name under different scopes will not conflict

### 分类

### Global scope

Objects that can be accessed anywhere in the code have global scope

Generally speaking, the following situations have global scope:

- Outermost function

- All variables that are directly assigned values without definition, will automatically have the global scope

- All attributes with window objects have global scope

### Function scope

因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了

```注意：```块语句（大括号“｛｝”中间的语句），如 if 条件语句或 for 循环语句，不会创建一个新的作用域

```javascript
if (true) {
    // 'if' 条件语句块不会创建一个新的作用域
    var name = 'Hammad'; // name 依然在全局作用域中
}
console.log(name); // logs 'Hammad'
```

### Block scope（ES6）

Block-level scope can be declared by ```let``` and ```const```

The declared variable cannot be accessed outside the scope of the specified block

#### Block Scope will be created in the following situations

1. Inside a function

2. Inside a code block (enclosed by a pair of curly braces)

#### Block Scope has the following characteristics

- No variable lift

- No duplicate claims

---

<span id="jump5"></span>

## Scope Chain

### 定义

当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链

### 作用域链的创建过程

一个函数的作用域链的创建分为函数的创建和激活两个时期

#### 函数创建时期

函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父AO到其中

例如：

```javascript
function foo() {
    function bar() {
        ...
    }
}
```

函数创建时，各自的[[scope]]为：

```javascript
foo.[[scope]] = [
  globalContext.VO
];

bar.[[scope]] = [
    fooContext.AO,
    globalContext.VO
];
```

#### 函数激活时期

当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端

这时候执行上下文的作用域链，我们命名为 Scope：

```javascript
Scope = [AO].concat([[Scope]]);
```

至此，作用域链创建完毕

---

<span id="jump7"></span>

## JS程序执行的流程

以一段代码为例：

```javascript
var scope = "global scope";
function checkscope(){
    var scope2 = 'local scope';
    return scope2;
}
checkscope();
```

### 创建全局执行上下文

JS执行全局代码，创建全局执行上下文

全局上下文被压入执行上下文栈

```javascript
ECStack = [
  globalContext
];
```

### 全局上下文初始化

```javascript
globalContext = {
  VO: [global],
  Scope: [globalContext.VO],
  this: globalContext.VO
}
```

### 保存函数作用域链

初始化的同时，checkscope 函数被创建

作用域链被保存到函数的内部属性[[scope]]

```javascript
checkscope.[[scope]] = [
  globalContext.VO
];
```

### 创建函数执行上下文

创建 checkscope 函数执行上下文

checkscope 函数执行上下文被压入执行上下文栈

```javascript
ECStack = [
  checkscopeContext,
  globalContext
];
```

### 复制作用域链

复制函数[[scope]]属性创建作用域链

```javascript
checkscopeContext = {
    Scope: checkscope.[[scope]],
}
```

### 创建活动对象

用 arguments 创建活动对象

初始化活动对象，即加入形参、函数声明、变量声明

```javascript
checkscopeContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope2: undefined
    }，
    Scope: checkscope.[[scope]],
}
```

### 更新作用域链

将活动对象压入 checkscope 作用域链顶端

```javascript
checkscopeContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope2: undefined
    },
    Scope: [AO, [[Scope]]]
}
```

### 执行函数

随着函数的执行，修改 AO 的属性值

```javascript
checkscopeContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope2: 'local scope'
    },
    Scope: [AO, [[Scope]]]
}
```

### 查找自由变量的值

沿着作用域链查找 scope2 值，在AO中找到

return

### 函数执行完毕

checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出

```javascript
ECStack = [
  globalContext
];
```

### 程序结束

全局执行上下文从执行上下文栈中弹出

```javascript
ECStack = [];
```
