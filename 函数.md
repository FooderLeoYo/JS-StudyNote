# 函数

## 目录

[Execution context](#jump1)

[Scope](#jump2)

[Closure](#jump3)

[构造函数，new 时发生了什么](#jump4)

[调用函数有哪几种方式](#jump5)

---	

<span id="jump1"></span>

## Execution context

### 什么是执行上下文

Is an abstract concept of the environment in which JavaScript code is executed


It contains the ```variables```, ```function declarations```, ```arguments```, ```scope chain```, ```this``` and other information in the current execution environment

### 分类

#### Global execution context

Any code that is not inside a function is in the global context

It will perform two things: create a global window object (in the case of a browser), and set the value of ```this``` equal to this global object

In a program, there will only be one global execution context 

#### Function Execution Context

Whenever a function is called, a new context will be created for this function

#### Eval Function Execution Context

开发者并不经常使用 eval，所以在这里不再讨论

### Execution stack

Also known as “call stack” 

It is used to store all execution contexts created when the code is run

JS is single-threaded and can only do one thing at a time, and other things will be queued in the specified context stack for execution

When the JavaScript engine encounters your script for the first time, it creates a global execution context and pushes it onto the current execution stack

Whenever the engine encounters a function call, it creates a new execution context for the function and pushes it to the top of the stack

The engine will execute those functions whose execution context is at the top of the stack. When the execution of the function ends, the execution context is popped from the stack, and the control flow reaches the next context in the current stack

### Life Cycle

The life cycle of the execution context: create -> execute -> recycle

#### The Creation Phase

##### Create Variable Object

Initialize parameters of the function

Function declaration lift

Variable lift

- The assignment part in the declaration statement will not be lifted, only the name will be lifted

- If the function has multiple parameters with the same name, the last parameter (even if it is not defined) will override the previous one

-The priority of function declaration is higher than variable. If the variable name is the same as the function name and is not assigned, the function declaration will overwrite the variable declaration

##### Creact Scope Chain

##### Determine what ```this``` will point at 

#### Execution phase

Perform variable assignment, function reference, and other code execution

#### recycle phase

The execution context is popped out of the stack and recycled by the garbage collection mechanism

---

<span id="jump2"></span>

## Scope

### 定义

The current context of execution

Scope likes an independent territory so that variables will not be leaked or exposed

The role of scope is to isolate variables, and variables with the same name under different scopes will not conflict

### 分类

### Global scope

Objects that can be accessed anywhere in the code have global scope

Generally speaking, the following situations have global scope:

- Outermost function

- All variables that are directly assigned values without definition, will automatically have the global scope

- All attributes with window objects have global scope

### Function scope

Scope of variables declared inside the function

```注意：```块语句（大括号“｛｝”中间的语句），如 if 条件语句或 for 循环语句，不会创建一个新的作用域

```javascript
if (true) {
    // 'if' 条件语句块不会创建一个新的作用域
    var name = 'Hammad'; // name 依然在全局作用域中
}
console.log(name); // logs 'Hammad'
```

### Block scope（ES6）

Block-level scope can be declared by ```let``` and ```const```

The declared variable cannot be accessed outside the scope of the specified block

#### Block Scope will be created in the following situations

1. Inside a function

2. Inside a code block (enclosed by a pair of curly braces)

#### Block Scope has the following characteristics

- No variable lift

- No duplicate claims

### Scope Chain

#### Free variable

Variables that are not defined in the current scope are called ```free variables```

```javascript
var a = 100
function fn() {
    var b = 200
    console.log(a) // 这里的a在这里就是一个自由变量
    console.log(b)
}
fn()
```

#### Scope Chain

Is the process of finding the value of a free variable, argument or function

The JS engine scans for the value of the variable, argument or function layer by layer until it reaches the global scope. If it still does not find it, then gives up

This layer-by-layer relationship is the scope chain

#### About the value of free variables

Go to the scope where the ```fn``` function was created, no matter where the ```fn``` function will be called

例1：

```javascript
var x = 10
function fn() {
  console.log(x)
}
function show(f) {
  var x = 20
  (function() {
    f() // 10，而不是20
  })()
}

show(fn)
```

例2：

```javascript
var a = 10
function fn() {
  var b = 20
  function bar() {
    console.log(a + b) // 30
  }
  return bar
}

var x = fn(),
  b = 200
x() 
```

分析：

fn()返回的是bar函数，执行x()，即执行bar函数代码

因此取b的值时，直接在fn作用域取

取a的值时，试图在fn作用域取，但是取不到，只能转向创建fn的那个作用域中去查找

所以最后的结果是30

---

<span id="jump3"></span>

## Closure

[闭包学习笔记](https://github.com/FooderLeoYo/JS-StudyNote/blob/master/%E9%97%AD%E5%8C%85.md)

---

<span id="jump4"></span>

## 执行构造函数，new时发生了什么

### 发生了什么

当执行```let o = new Foo();```时，实际上执行了如下操作：

1. Create a new object obj

```javascript
let o = {};
let [Foo, ...args] = [...arguments];  // 第一个参数是构造函数
```

2. Prototype chain connection: point the ```proto``` of this empty object to the ```prototype``` of the function 

```javascript
o.__proto__ = Foo.prototype;
```

3. Replace the ```this``` pointer of the function with o, and add the properties and methods of the constructor to this new empty object

```javascript
let result = Foo.apply(o, args);
```

4. If the result returned by the constructor is an object, return this object; otherwise return the created new object

```javascript
if(result && (typeof result == "object" || typeof result == "function")){
  // 如果构造函数返回的结果是一个对象，就返回这个对象
  return result;
}
// 如果构造函数返回的不是一个对象，就返回创建的新对象。
return o;
```

### 类似的问题：如何实现一个 new

```javascript
function _new(func, ...args) {
  let obj = Object.create(func.prototype); // 原型
  let res = func.apply(obj, args); // 初始化对象属性
  return res instanceof Object ? res : obj; // 返回值
}
```

---

<span id="jump5"></span>

## 调用函数有哪几种方式

- 方法调用模式 Foo.foo(arg1, arg2);

- 函数调用模式 foo(arg1, arg2);

- 构造器调用模式 (new Foo())(arg1, arg2);

- call/apply 调用模式 Foo.foo.call(that, arg1, arg2);

- bind 调用模式 Foo.foo.bind(that)(arg1, arg2)();
